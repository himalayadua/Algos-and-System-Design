# Problem Solving Interviews
WHAT to prepare for Problem Solving Interviews?

1.  DATA STRUCTURES

    1.  Arrays

    2.  Linked List

    3.  Stack

    4.  Queue

    5.  Binary Tree

    6.  Binary Search Tree (BST)

    7.  Heap/Priority Queue

    8.  Graphs

    9.  Trie (Optional)

2.  ALGORITHMIC APPROACHES

    1.  Greedy

    2.  Recursion & Dynamic Programming (Very Important)

        1.  Iterative Approach

        2.  Recursion + Memoization Approach

    3.  Backtracking

    4.  Divide and Conquer

3.  STANDARD TECHNIQUES/PATTERNS

    1.  Two-Pointer Technique

    2.  Fast and Slow Pointers

    3.  Sliding Window

    4.  Heap/Priority Queue

    5.  Hashing

    6.  Breadth-First Search

    7.  Depth-First Search

    8.  Bit-wise Operations like XOR

4.  FAMOUS ALGORITHMS

    1.  Tortoise Hare Algorithm

    2.  Dutch National Flag Algorithm

    3.  Quick Select Algorithm

    4.  Kadane's Algorithm

    5.  Lee's Algorithm

    6.  Boyer-Moore Algorithm

    7.  Task Scheduling Algorithm

    8.  Floyd's Cycle-Finding Algorithm

    9.  Morris Traversal Algorithm

    10. Knuth-Morris-Pratt (KMP) Algorithm

    11. Other Graph Algorithms (listed in the next section)

## Overall Preparation  - CONCEPT WISE

1.  Data Types & Ranges

    -   How to derive a range for data type? (Internal working of Bits).

2.  Bit-wise Operations

    -   AND, OR, XOR, 1's Complement, 2's Complement

    -   (Optional) How are Negative Integers represented?

    -   (Optional) Types of Representations: Sign Magnitude Form, 1's Complement Form, 2's Complement Form

3.  Arrays

    -   Basics - Creating an array, Assigning Values & Printing the array

    -   Types of Arrays - Single Dimensional & Multi-Dimensional

    -   Searching

        -   Linear Search

        -   Binary Search

    -   Sorting

        -   Selection Sort

        -   Insertion Sort

        -   Merge Sort

        -   Quick Sort

        -   Heap Sort (Very Important, used in PriorityQueue data structure)

    -   Problems on Arrays

4.  Time Complexity & Space Complexity Analysis

    1.  O(n)

    2.  O(logn)

    3.  O(1)

    4.  O(n2)

    5.  O(n3)

    6.  O(nlogn)

5.  Memory Allocation, Heap, Stack

6 . Dynamic Programming

    1.  Recursion & its problems. Stack Memory Consumption in Recursion

    2.  Memoization

    3.  Optimal Substructure

    4.  Overlapping Sub problems

    5.  Iterative Dynamic Programming

    6.  Problems

7. Linked List

    -   Basics & Implementation

        -   Insertion, Deletion, Searching

    -   Why Linked List? 

    -   Linked List Vs Arrays

    -   Doubly Linked List

    -   Applications of Linked List - Stack, Queue, Deque etc.

    -   Problems on Linked List

8. Stack & Queue

    1.  Basics & Implementation

    2.  LIFO Vs FIFO

    3.  Infix, Postfix & Prefix Notations & Conversions

9. Binary Trees

    1.  Basics & Implementation

        1.  Structure & Implementation

        2.  Depth of a Node

        3.  Height of a Node

        4.  Types of Trees - Binary Tree, Quad Tree etc.

        5.  Types of Trees - Full Binary Tree, Complete Binary Tree, Perfect Binary Tree

        6.  Binary Search Tree & Purpose

    2.  Applications of Binary Trees

    3.  Traversals

        1.  Breadth First Search (BFS)

        2.  Depth First Search (DFS) - PreOrder, InOrder, PostOrder

        3.  Applications

    4.  Balanced Binary Trees & Purpose

        1.  AVL Tree

        2.  Red Black Tree

10. Graphs

    1.  Basics & Terminology

        1.  What is Vertex/Node?

        2.  What is Edge?

        3.  Weighted Graph Vs Unweighted Graph

        4.  Directed Graph Vs Undirected Graph

        5.  Dense Vs Sparse Graph

        6.  Cyclic Vs Acyclic Graph

        7.  Strongly Connected vs Weakly Connected Graph

        8.  In-degree Vs Out-degree

        9.  Applications of Graphs

    2.  Representations/Implementations

        1.  Using Edges List

        2.  Using Adjacency Matrix

        3.  Using Adjacency List

    3.  Traversals (BFS & DFS)

    4.  Cycle Detection

    5.  Standard Algorithms

        1.  Dijkstras Algorithm

        2.  Bellman Ford Algorithm

        3.  Floyd Warshall Algorithm

        4.  Prims Algorithm - Minimum Cost Spanning Tree

        5.  Kruskals Algorithm - Minimum Cost Spanning Tree

        6.  Union Find Algorithm

        7.  Topological Sort (Very Important)

        8.  Tarjan's Algorithm - Finding Strongly Connected Components of a Graph (Very Important)

        9.  Tarjan's Algorithm - Finding Articulation Points & Critical Connections of a Graph

        10. (Optional) Graph Coloring

    6.  Problems on Graphs